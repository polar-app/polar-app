// AUTOGENERATED. DO NOT EDIT MANUALLY

service cloud.firestore {
  match /databases/{database}/documents {
    function existsGroup() {
        return exists(/databases/$(database)/documents/group/$(resource.data.groupID));
    }
    
    function getGroup() {
        return get(/databases/$(database)/documents/group/$(resource.data.groupID));
    }
    
        
    /**
     * Determine if the user has a profileID via the profile_owner table
     */
    function hasProfileID() {
        return exists(/databases/$(database)/documents/profile_owner/$(request.auth.uid));
    }
    
    /**
     * Get the users profileID via the profile_owner table
     */
    function getProfileID() {
        return get(/databases/$(database)/documents/profile_owner/$(request.auth.uid)).data.profileID;
    }
    
    function matchesProfileID(profileID) {
        return hasProfileID() && profileID == getProfileID();
    }
        
    function hasUserGroup() {
        return exists(/databases/$(database)/documents/user_group/$(request.auth.uid));
    }
    
    function getUserGroup() {
        return get(/databases/$(database)/documents/user_group/$(request.auth.uid));
    }
    
    function isPermittedGroupWithinSet(allowedGroups, groups) {
        return allowedGroups != null && allowedGroups.hasAny(groups);
    }
    
    function isPermittedGroup(groupID) {
        return hasUserGroup() &&
               isPermittedGroupWithinSet(getUserGroup().data.groups, [groupID]) ||
               isPermittedGroupWithinSet(getUserGroup().data.invitations, [groupID]);
    }
    
    /**
     */
    function isPermittedGroups(groups) {
        return hasUserGroup() &&
               isPermittedGroupWithinSet(getUserGroup().data.groups, groups) ||
               isPermittedGroupWithinSet(getUserGroup().data.invitations, groups);
    }
    
    
    match /account/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read: if request.auth.uid == resource.data.uid;
        
        
    }
        
    match /block/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read, write: if (resource == null || request.auth.uid == resource.data.uid);
        
        
    }
        
    match /contact/{document=**} {
        
        allow read, write: if request.auth.uid == resource.data.uid;
        
    }
        
    match /doc_file_meta/{document=**} {
        // this rule is shared with both doc_info and doc_meta
        
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // if the visibility is public we're ok with sharing
        allow read: if resource.data.visibility == 'public';
        
        // if the visibility is public we're ok with sharing
        allow read: if resource.data.visibility == 'protected';
        
        // If the user is the owner they can read it obviously
        allow read: if request.auth != null && request.auth.uid == resource.data.uid;
        
        // allow read on this document if it was added by the user to a group.
        allow read: if resource.data.keys().hasAny(['groups']) && resource.data.groups.size() > 0 && isPermittedGroups(resource.data.groups);
        
        allow write: if request.auth != null && (resource == null || request.auth.uid == resource.data.uid);
        
    }
        
    match /doc_info/{document=**} {
        // this rule is shared with both doc_info and doc_meta
        
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // if the visibility is public we're ok with sharing
        allow read: if resource.data.visibility == 'public';
        
        // if the visibility is public we're ok with sharing
        allow read: if resource.data.visibility == 'protected';
        
        // If the user is the owner they can read it obviously
        allow read: if request.auth != null && request.auth.uid == resource.data.uid;
        
        // allow read on this document if it was added by the user to a group.
        allow read: if resource.data.keys().hasAny(['groups']) && resource.data.groups.size() > 0 && isPermittedGroups(resource.data.groups);
        
        allow write: if request.auth != null && (resource == null || request.auth.uid == resource.data.uid);
        
    }
        
    match /doc_meta/{document=**} {
        // this rule is shared with both doc_info and doc_meta
        
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // if the visibility is public we're ok with sharing
        allow read: if resource.data.visibility == 'public';
        
        // if the visibility is public we're ok with sharing
        allow read: if resource.data.visibility == 'protected';
        
        // If the user is the owner they can read it obviously
        allow read: if request.auth != null && request.auth.uid == resource.data.uid;
        
        // allow read on this document if it was added by the user to a group.
        allow read: if resource.data.keys().hasAny(['groups']) && resource.data.groups.size() > 0 && isPermittedGroups(resource.data.groups);
        
        allow write: if request.auth != null && (resource == null || request.auth.uid == resource.data.uid);
        
    }
        
    match /doc_permission/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // If the user is the owner they can read it obviously
        allow read, write: if request.auth != null && request.auth.uid == resource.data.uid;
        
    }
        
    match /doc_preview/{document=**} {
        
        // allow reads by ID which would give us metadata about a doc before I added it
        // to the repo
        allow read;
        
    }
        
    match /event/{document=**} {
        allow write;
        
    }
        
    match /group/{document=**} {
        
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // TODO: what if the group has been flagged as deleted?
        
        allow read: if ['public', 'protected'].hasAny([resource.data.visibility]);
        
        // only allow members of this group to read which documents are
        // contained here. Writes are not allowed because they are implemented
        // via a cloud hook.
        allow read: if isPermittedGroup(resource.data.id);
        
    }
        
    match /group_admin/{document=**} {
        // no user permissions on this table. Its only enforced for writes.
        
        // a user doesn't need to read this as they can determine if they are
        // an admin on a table by their own user_group table as it has an
        // 'admins' field.
        
        allow read, write: if false;
        
    }
        
    match /group_doc/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // allows us to lookup the group by group_id and see if the visibility allows
        // access or if the user is already in the group as a member.
        
        // we can read/write if the group is public
        allow read: if existsGroup() && ['public', 'protected'].hasAny([getGroup().data.visibility]);
        
        // only allow members of this group to read which documents are
        // contained here. Writes are not allowed because they are implemented
        // via a cloud hook.
        allow read: if existsGroup() && isPermittedGroup(resource.data.groupID);
        
        // allow write if the user is the owner by looking at their profileID.
        allow write: if hasProfileID() && getProfileID() == resource.data.profileID;
        
    }
        
    match /group_doc_annotation/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // allows us to lookup the group by group_id and see if the visibility allows
        // access or if the user is already in the group as a member.
        
        allow read: if ['public', 'protected'].hasAny([resource.data.visibility]);
        
        // we can read/write if the group is public
        allow read: if existsGroup() && ['public', 'protected'].hasAny([getGroup().data.visibility]);
        
        // only allow members of this group to read which documents are
        // contained here. Writes are not allowed because they are implemented
        // via a cloud hook.
        allow read: if existsGroup() && isPermittedGroup(resource.data.groupID);
        
        
    }
        
    match /group_doc_info/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // allows us to lookup the group by group_id and see if the visibility allows
        // access or if the user is already in the group as a member.
        
        // we can read/write if the group is public
        allow read: if existsGroup() && ['public', 'protected'].hasAny([getGroup().data.visibility]);
        
        // only allow members of this group to read which documents are
        // contained here. Writes are not allowed because they are implemented
        // via a cloud hook.
        allow read: if existsGroup() && isPermittedGroup(resource.data.groupID);
        
        // allow write if the user is the owner by looking at their profileID.
        allow write: if hasProfileID() && getProfileID() == resource.data.profileID;
        
    }
        
    match /group_member/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // allows us to lookup the group by group_id and see if the visibility allows
        // access or if the user is already in the group as a member.
        
        // we can read/write if the group is public
        allow read: if existsGroup() && ['public', 'protected'].hasAny([getGroup().data.visibility]);
        
        // only allow members of this group to read which documents are
        // contained here. Writes are not allowed because they are implemented
        // via a cloud hook.
        allow read: if existsGroup() && isPermittedGroup(resource.data.groupID);
        
        // allow write if the user is the owner by looking at their profileID.
        allow write: if hasProfileID() && getProfileID() == resource.data.profileID;
        
    }
        
    match /group_member_invitation/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // If the user is the owner (by email) they can read it.
        allow delete, read: if request.auth != null && request.auth.token.email == resource.data.to;
        
        // allow write if the user is the owner by looking at their profileID.
        allow read: if resource.data.from != null && matchesProfileID(resource.data.from.profileID);
        
        // TODO: also allow us to list all invitations for a specific group if the user
        // is the admin of that group
        
    }
        
    match /heartbeat/{document=**} {
        allow write;
        
    }
        
    match /machine_datastore/{document=**} {
        
        // Only allow get. do not allow read/list.  This allows us to give users
        // permission to read their own record but not run queries or list.
        // There is a amazingly mild security issue here which even if violated
        // wouldn't amount to anything significant.
        
        allow get;
        
        allow write;
        
    }
        
    match /profile/{document=**} {
        // all profiles are public by default.  There should be no personal data in
        // user like email or uid.
        allow read;
        
    }
        
    match /profile_doc_annotation/{document=**} {
        // for now all annotations on this user profile are public for their public documents 
        allow read;
        
        
    }
        
    match /profile_handle/{document=**} {
        // anyone can read this. Just allows us to lookup a profile ID based on handle.
        allow read;
        
    }
        
    match /profile_owner/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read: if request.auth.uid == resource.data.uid;
        
        
    }
        
    match /spaced_rep/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read, write: if (resource == null || request.auth.uid == resource.data.uid);
        
        
    }
        
    match /spaced_rep_stat/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read, write: if (resource == null || request.auth.uid == resource.data.uid);
        
        
    }
        
    match /sync_entity/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read, write: if (resource == null || request.auth.uid == resource.data.uid);
        
        
    }
        
    match /unique_machines/{document=**} {
        allow read, write;
        
    }
        
    match /user_feedback/{document=**} {
        allow write;
        
    }
        
    match /user_group/{document=**} {
        
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read: if request.auth.uid == resource.data.uid;
        
    }
        
    match /user_pref/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read, write: if (resource == null || request.auth.uid == resource.data.uid);
        
        
    }
        
    match /user_referral/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read, write: if (resource == null || request.auth.uid == resource.data.uid);
        
        
    }
        
    match /user_referral_claim/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read, write: if (resource == null || request.auth.uid == resource.data.uid);
        
        
    }
        
    match /user_trait/{document=**} {
        // allow reads on resources that aren't present.  This is critical because if
        // we do not have this rule then when a user tries to read a document that
        // does not exist then they will get a "permission failed" error/exception.
        // We also need to do this FIRST so that no other rule is evaluated since
        // they might result in null pointer exceptions when trying to read the data
        // property on a record that does not exist.
        allow delete, read: if resource == null || resource.data == null;
        
        // only allow the user to read their own account
        allow read, write: if (resource == null || request.auth.uid == resource.data.uid);
        
        
    }
    
  }
}
